---
id: useAsyncRetryer
title: useAsyncRetryer
---

<!-- DO NOT EDIT: this page is autogenerated from the type comments -->

# Function: useAsyncRetryer()

```ts
function useAsyncRetryer<TFn, TSelected>(
   fn, 
   options, 
selector): ReactAsyncRetryer<TFn, TSelected>
```

Defined in: [react-pacer/src/async-retryer/useAsyncRetryer.ts:152](https://github.com/TanStack/pacer/blob/main/packages/react-pacer/src/async-retryer/useAsyncRetryer.ts#L152)

A low-level React hook that creates an `AsyncRetryer` instance to retry execution of an async function.

This hook is designed to be flexible and state-management agnostic - it simply returns a retryer instance that
you can integrate with any state management solution (useState, Redux, Zustand, Jotai, etc).

Async retrying automatically re-executes a failed async function up to a specified number of attempts with
configurable backoff strategies. This is useful for handling transient errors like network failures, temporary
server issues, or rate limiting where you want to automatically retry the operation.

Error Handling:
- If an `onError` handler is provided, it will be called for every error during execution
- If an `onLastError` handler is provided, it will be called only for the final error after all retries fail
- If `throwOnError` is 'last' (default), only the final error after all retries will be thrown
- If `throwOnError` is true, every error will be thrown immediately (disables retrying)
- If `throwOnError` is false, errors are never thrown and undefined is returned instead

## State Management and Selector

The hook uses TanStack Store for reactive state management. The `selector` parameter allows you
to specify which state changes will trigger a re-render, optimizing performance by preventing
unnecessary re-renders when irrelevant state changes occur.

**By default, there will be no reactive state subscriptions** and you must opt-in to state
tracking by providing a selector function. This prevents unnecessary re-renders and gives you
full control over when your component updates. Only when you provide a selector will the
component re-render when the selected state values change.

Available state properties:
- `currentAttempt`: The current retry attempt number (0 when not executing)
- `executionCount`: Total number of completed executions (successful or failed)
- `isExecuting`: Whether the retryer is currently executing the function
- `lastError`: The most recent error encountered during execution
- `lastExecutionTime`: Timestamp of the last execution completion in milliseconds
- `lastResult`: The result from the most recent successful execution
- `status`: Current execution status ('disabled' | 'idle' | 'executing' | 'retrying')
- `totalExecutionTime`: Total time spent executing (including retries) in milliseconds

## Type Parameters

• **TFn** *extends* `AnyAsyncFunction`

• **TSelected** = \{\}

## Parameters

### fn

`TFn`

### options

`AsyncRetryerOptions`\<`TFn`\>

### selector

(`state`) => `TSelected`

## Returns

[`ReactAsyncRetryer`](../../interfaces/reactasyncretryer.md)\<`TFn`, `TSelected`\>

## Example

```tsx
// Default behavior - no reactive state subscriptions
const apiRetryer = useAsyncRetryer(
  async (userId: string) => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) throw new Error('Failed to fetch user');
    return response.json();
  },
  { maxAttempts: 3, backoff: 'exponential' }
);

// Opt-in to re-render when execution state changes (optimized for loading indicators)
const apiRetryer = useAsyncRetryer(
  async (userId: string) => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) throw new Error('Failed to fetch user');
    return response.json();
  },
  { maxAttempts: 3, backoff: 'exponential' },
  (state) => ({
    isExecuting: state.isExecuting,
    currentAttempt: state.currentAttempt
  })
);

// Opt-in to re-render when results are available (optimized for data display)
const apiRetryer = useAsyncRetryer(
  async (userId: string) => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) throw new Error('Failed to fetch user');
    return response.json();
  },
  { maxAttempts: 3, backoff: 'exponential' },
  (state) => ({
    lastResult: state.lastResult,
    executionCount: state.executionCount
  })
);

// Opt-in to re-render when error state changes (optimized for error handling)
const apiRetryer = useAsyncRetryer(
  async (userId: string) => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) throw new Error('Failed to fetch user');
    return response.json();
  },
  {
    maxAttempts: 3,
    backoff: 'exponential',
    onError: (error) => console.error('API call failed:', error),
    onLastError: (error) => console.error('All retries failed:', error)
  },
  (state) => ({
    lastError: state.lastError,
    status: state.status
  })
);

// With state management
const [userData, setUserData] = useState(null);
const { execute, state } = useAsyncRetryer(
  async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) throw new Error('Failed to fetch user');
    const data = await response.json();
    setUserData(data);
    return data;
  },
  {
    maxAttempts: 5,
    backoff: 'exponential',
    baseWait: 1000,
    onRetry: (attempt, error) => {
      console.log(`Retry attempt ${attempt} after error:`, error);
    },
    onError: (error) => {
      console.error('Request failed:', error);
    }
  }
);

// Access the selected state (will be empty object {} unless selector provided)
const { isExecuting, currentAttempt } = state;
```
